#!/usr/bin/env python
'''Example simulation + CCM analysis script. Should be copied and modified for particular experiments.
Can be used by itself
'''

import os
SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
import sys
# Uncomment and modify this to point to the right location for pyembedding
# sys.path.append(os.path.join(SCRIPT_DIR, 'pyembedding'))
import subprocess
import multiprocessing
import numpy
import pyembedding
import uzalcost
import jsonobject
import models
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot

# Initialize model-specific parameters
# JSONObject is a convenience object that lets you access JSON keys using dot-notation or bracket-notation
# and automatically converts lists to NumPy arrays.
params = jsonobject.JSONObject({
    'n_pathogens' : 2,

    'dt_euler' : 0.01,
    'adaptive' : False,
    'tol' : 1e-6,
    't_end' : 72000.0,
    'dt_output' : 30.0,

    'mu' : 0.00054794520548,
    'nu' : [0.2, 0.2],
    'gamma' : [0.0, 0.0],

    'beta0' : [0.22, 0.22],
    'S_init' : [0.5, 0.5],
    'I_init' : [0.05, 0.05],
    'beta_change_start' : [0.0, 0.0],
    'beta_slope' : [0.0, 0.0],
    'psi' : [360.0, 360.0],
    'omega' : [0.0, 0.0],
    'eps' : [0.1, 0.1],
    'sigma' : [[1.0, 0.01], [0.0, 1.0]],

    'shared_proc' : False,
    'sd_proc' : [0.00, 0.00],

    'shared_obs' : False,
    'sd_obs' : [0.0, 0.0],

    'shared_obs_C' : False,
    'sd_obs_C' : [1e-2, 1e-2]
})

n_ccm_bootstraps = 1000

# If there are extra parameters in a file (generated by a sweep), load them, overriding existing values.
if os.path.exists('sir_params.json'):
    params.update_from_file('sir_params.json')

if os.path.exists('job_info.json'):
    job_info = jsonobject.load_from_file('job_info.json')
else:
    job_info = jsonobject.JSONObject(job_id = 0)

def main():
    jsonobject.JSONObject(
        job_id = job_info.job_id,
        status = 'running'
    ).dump_to_file('status.json')

    # Run a real simulation (see models.py for model implementation):
    if os.path.exists('sir_out.json'):
        sir_out = jsonobject.load_from_file('sir_out.json')
    else:
        try:
            sir_out = models.run_via_pypy('multistrain_sde', params)
            sir_out.dump_to_file('simulation_output.json')
        except models.ExecutionException as e:
            sys.stderr.write('{0}\n'.format(e.cause))
            sys.stderr.write(e.stderr_data)
            sys.exit(1)
    C0 = sir_out.C[-1200:, 0]
    C1 = sir_out.C[-1200:, 1]

    # Or, comment out the above and uncomment the following to run a fake simulation:
    # C0 = numpy.random.normal(0, 1, size=1200)
    # C1 = numpy.random.normal(0, 1, size=1200)

    plot_timeseries('C0', C0)
    plot_timeseries('C1', C1)

    run_analysis('C0', C0, 'C1', C1)
    run_analysis('C1', C1, 'C0', C0)

    jsonobject.JSONObject(
        job_id = job_info.job_id,
        status = 'complete'
    ).dump_to_file('status.json')


def plot_timeseries(name, timeseries):
    fig = pyplot.figure()
    pyplot.plot(timeseries)
    pyplot.xlabel('time (months)')
    pyplot.ylabel(name)
    pyplot.savefig(name + '.png')
    pyplot.close(fig)

def run_analysis(cname, cause, ename, effect):
    '''Run analysis for a single direciton: called for C0->C1 and C1->C0 below.'''
    sys.stderr.write('Running {0}-causes-{1}\n'.format(cname, ename))

    # Identify delay at which autocorrelation drops to 1/e
    ac_delay, autocorr = pyembedding.autocorrelation_threshold_delay(effect, 1.0/numpy.e)
    sys.stderr.write('  ac_delay, autocorr = {0}, {1}\n'.format(ac_delay, autocorr))

    # Calculate Theiler window (limit on closeness of neighbors in time)
    theiler_window = 3 * ac_delay
    sys.stderr.write('  theiler_window = {0}\n'.format(theiler_window))
    assert theiler_window < effect.shape[0]

    # Calculate maximum prediction horizon (used by Uzal cost function)
    prediction_horizon = 2 * theiler_window
    sys.stderr.write('  prediction_horizon = {0}\n'.format(prediction_horizon))
    assert prediction_horizon > theiler_window

    # Hard-code maximum delay vector window:, equal to delay * (embedding_dimension - 1)
    max_window = 60
    sys.stderr.write('  max_window = {0}\n'.format(max_window))
    assert max_window > prediction_horizon

    # Run Uzal cost function (will implicitly compile Uzal's C code if necessary)
    ms, Lks, params = uzalcost.run_uzal_costfunc(
        effect, theiler_window=theiler_window, max_prediction_horizon=prediction_horizon,
        max_window=max_window
    )
    best_m_index = numpy.argmin(Lks)
    embedding_dimension = ms[best_m_index]
    sys.stderr.write('  Uzal full embedding dimension = {0} (Lk = {1})\n'.format(embedding_dimension, Lks[best_m_index]))

    # Run Nichkawde algorithm to identify sub-embedding
    full_embedding = pyembedding.Embedding(effect, range(embedding_dimension))
    sub_embedding = full_embedding.identify_nichkawde_subembedding(theiler_window)
    sys.stderr.write('  Nichkawde sub-embedding: {0}\n'.format(sub_embedding.delays))

    # min library size: embedding_dimension + 2,
    # so vectors should usually have embedding_dimension + 1 neighbors available
    Lmin = sub_embedding.embedding_dimension + 2

    # max library size: just the number of available delay vectors
    Lmax = sub_embedding.delay_vector_count

    sys.stderr.write('  Using Lmin = {0}, Lmax = {1}\n'.format(Lmin, Lmax))

    assert Lmax > Lmin

    corrs_Lmin = run_ccm_bootstraps(sub_embedding, cause, Lmin, theiler_window)
    corrs_Lmax = run_ccm_bootstraps(sub_embedding, cause, Lmax, theiler_window)

    # effect_sampled_embedding = effect_embedding.sampled_embedding(100, replace=True)
    # ccm_result, y_actual, y_pred = effect_sampled_embedding.ccm(effect_embedding, cause, theiler_window=theiler_window)
    # print ccm_result.dump_to_string()

def run_ccm_bootstraps(embedding, cause, L, theiler_window):
    assert isinstance(embedding, pyembedding.Embedding)

    for i in range(n_ccm_bootstraps):
        sampled_embedding = embedding.sample_embedding(L, replace=True)
        ccm_result, y_actual, y_pred = sampled_embedding.ccm(embedding, cause, theiler_window=theiler_window)
        ccm_result.dump_to_file(sys.stderr)

if __name__ == '__main__':
    main()
